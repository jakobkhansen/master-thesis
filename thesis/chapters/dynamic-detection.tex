\chapter{Implementation: Incremental detection}

The following chapter will present the algorithm which efficiently updates the list of
clones, without having to rebuild the different structures from scratch. Given an edit
to a file in the project, we will be able to update the document index, fingerprints,
suffix array and list of clones faster than the initial detection.

An incremental update is run whenever a document is changed. The document index is
signalized of a change either when a file is saved, or on any keystroke. This is
configurable by the client. When the document index is changed, an incremental update of
the clones is run, and the clone-list is updated.

\section{Affordable operations}

Before looking at the approach, it is useful to determine the time cost associated with
different operations. If we can for example afford to iterate over the contents of a
single file, that will be useful for our algorithm. Table \ref{table:affordableoperations}
shows which operations are affordable or not for an incremental update.

\begin{table}[t!]
	\begin{center}
		\begin{tabular}{|p{1in} | p{1in} | p{0.6in} | p{2.5in}|}
			\hline

			Description                    & Complexity              & Affordable & Explanation                               \\\hline

			Content of all files           & $O(|\Var{code\ base}|)$ & No         & Iterating over the
			entire code base will be the same complexity as the initial detection,
			therefore this operation is too slow.                                                                             \\\hline

			Content of a file              & $O(|\Var{file}|)$       & Yes        & Iterating over the content
			of a single file is likely a very small percentage of the entire code
			base.                                                                                                             \\\hline

			Parsing a file                 & $O(|\Var{file}|)$       & No         & While the complexity of
			parsing a single file is still linear in the size of the file, parsing a large
			file from scratch can take a significant amount of time in practice.                                              \\\hline

			Incrementally reparsing a file & $O(|\Var{edit}|)$       & Yes        & Re-using the
			AST of a file in order to speed up the parsing of the same file with
			after an edit is significantly faster than parsing the entire file.                                               \\\hline

			Document index                 & $O(|\Var{documents}|)$  & Yes        & The number of files in a code
			base is likely many orders of magnitude smaller than the size of the code base
			itself.                                                                                                           \\\hline

			Clones                         & $O(|\Var{clones}|)$     & Yes        & The number of clones in the code base and
			the area they cover is likely a very small portion of the code base itself.
			itself.                                                                                                           \\\hline
		\end{tabular}
		\caption{Affordable operations for incremental updates}
		\label{table:affordableoperations}
	\end{center}
\end{table}


\section{Updating the document index}

The first step of an incremental update is to update the document index. We will also look
at how we can reduce memory usage of the index without a loss in terms of the time
complexity of the updates.

As shown in the document interface, each document stores its own content, AST and
fingerprint. It is not strictly necessary to store either the content or the AST in memory
all the time, as it is likely that only a handful of files are open in the IDE at once.
Therefore, in the initial detection, we can free the memory of the file content and AST
for each document after the fingerprint has been computed. However, if a file is opened in
the IDE, the file can now be changed, so we should facilitate efficient updates for these
files only. When a file is opened, the file content should be read from the disk and
updated via the \verb|textDocument/didChange| messages sent from the client. It is also
important to keep the AST of the opened file in memory in order to facilitate incremental
reparsing of the opened files. 

When a file is opened, the LSP client sends a \verb|textDocument/didOpen| message to the
server, which finds the relevant document $D$ in the index, and sets the following fields:

\begin{flalign*}
&\Access{D}{open} = \True \\
&\Access{D}{AST} = \Parse{D} \\
&\Access{D}{content} = \Read{$\Access{D}{uri}$}
\end{flalign*}

After the document fields have been set, the document is ready to receive updates. When
the LSP client sends a \verb|textDocument/didChange| message, the message consists of the
URI of the edited file, the range of the content which has changed, and the content which
has potentially been inserted. This range is then used in a tree-sitter incremental
reparse of the file content. After this reparse, we have efficiently updated a documents
content and AST. After this update, we also set $\Access{D}{changed} = \True$

\section{Updating fingerprints}

With the updated AST for all documents, we can update the fingerprint of all documents
which have been changed. For each document $D$ where $\Access{D}{changed} = \True$, the
fingerprint for D may have changed. Calculating the fingerprint is the same process as in
the initial detection, where we first query the AST for all nodes of a certain type, then
for each matched node $N$, we extract and fingerprint all the tokens which $N$ covers,
using the same fingerprint mapping as was used for the initial detection.

An additional change we have to consider when incrementally updating fingerprints is that
for a document $D$, $\Access{D}{start}$ and $\Access{D}{end}$ which corresponds to the
range which $D$ covers in the fingerprint, may have changed. Also, any document $D_1$
where $\Access{D_1}{start} > \Access{D}{start}$ could also have its range changed. This is
solved while updating each documents fingerprint by counting the number of tokens in each
document after updating, and setting the appropriate \verb|start| and \verb|end| fields.

\Todo{Algorithm for updating document index here}

\Todo{Figure which displays three documents, with old and new fingerprint}

\section{Computing edit operations}

Now that the fingerprint has been updated, we could build the suffix array from scratch
and already see a substantial improvement in performance. The major bottleneck of the initial
detection is to parse and fingerprint the entire code base. However, the updating of the
suffix array can and should also be updated incrementally to further improve efficiency.

The input to the dynamic suffix array algorithm is a set of edit operations. Therefore, we
need to know what exactly has changed in the fingerprint before we can update the suffix
array. We need to determine what edit operations have happened. Edit operations are either
deleting, inserting or substituting a section of the code.

There are two approaches we could take to determine the edit operations. The first is to
look at the ranges that the LSP client sends with each \verb|textDocument/didChange|
message and determine which tokens in the fingerprint have been affected by this message.
However, this approach tightly couples the algorithm to LSP and the scenario where we know
the exact ranges of each change. Also, we might do unnecessary amounts of operations if we
do multiple edits, since some operations could cancel each other out, for example by
inserting and then deleting some text.

The other approach is to determine the changes of the fingerprint via an edit distance
algorithm. An edit distance algorithm is an algorithm which calculates the distance
between two strings $S_1$ and $S_2$. Distance between two strings is the minimum number of
edit operations (insert, delete, substitute) which is required to transform $S_1$ into
$S_2$. Many of the algorithms which calculates the edit distance also allows computing
what the operations are.

The classic algorithm for calculating edit distance operations is attributed to Wagner and
Fischer~\cite{WagnerFischer}. The input to the algorithm is two strings $S_1$ and $S_2$ of
length $n$ and $m$. The output will be the set of operations needed to turn $S_1$ into
$S_2$. This algorithm is based on dynamic programming where a matrix $M$ is filled from
top to bottom and then the operations are inferred from $M$. The recurrence in equation
\ref{eq:editdistancerecurrence} shows how the edit distance matrix is filled and
\ref{tab:wagnerfischermatrix} shows an example matrix.

\begin{figure}[t]
    \begin{center}
	$$
		\sum^{n}_{i = 0}{M[i][0] = i}
	$$
	$$
		\sum^{m}_{j = 0}{M[0][j] = j}
	$$

	\begin{gather*}
		M[i][j] =
		\begin{cases}
			M[i-1][j-1] & \mathrm{if\ } S_1[i] = S_2[j] \\
            1 + \Min{$M[i-1][j-1], M[i][j-1], M[i-1][j-1]$}
		\end{cases}
	\end{gather*}
	\caption{Edit distance recurrence}
	\label{eq:editdistancerecurrence}
    \end{center}
\end{figure}

Each index $i, j$ in $M$ contains the edit distance value between the substrings
$\ArrayAccess{S_1}{0..i}$ and $\ArrayAccess{S_2}{0..j}$ The values in $M$ is calculated by
determining what is the cheapest operation to do at a certain location to make the
substrings equal. This can be determined by looking at the three surrounding indices in
$M$: $\MatrixAccess{M}{i - 1}{j - 1}$, $\MatrixAccess{M}{i - 1}{j}$ and
$\MatrixAccess{M}{i}{j - 1}$. Each of these indices equate to deleting, inserting or
substituting a character in $S_1$. 

\begin{table}
	\begin{center}
		\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|}
			  &                      & D                    & E                    & M                    & O                    & C                    & R                    & A                    & T                    \\\hline
			  & \cellcolor{blue!25}0 & 1                    & 2                    & 3                    & 4                    & 5                    & 6                    & 7                    & 8                    \\\hline
			R & 1                    & \cellcolor{blue!25}1 & 2                    & 3                    & 4                    & 5                    & 5                    & 6                    & 7                    \\\hline
			E & 2                    & 2                    & \cellcolor{blue!25}1 & 2                    & 3                    & 4                    & 5                    & 6                    & 7                    \\\hline
			P & 3                    & 3                    & \cellcolor{blue!25}2 & 2                    & 3                    & 4                    & 5                    & 6                    & 7                    \\\hline
			U & 4                    & 4                    & \cellcolor{blue!25}3 & 3                    & 3                    & 4                    & 5                    & 6                    & 7                    \\\hline
			B & 5                    & 5                    & 4                    & \cellcolor{blue!25}4 & 4                    & 4                    & 5                    & 6                    & 7                    \\\hline
			L & 6                    & 6                    & 5                    & 5                    & \cellcolor{blue!25}5 & 5                    & 5                    & 6                    & 7                    \\\hline
			I & 7                    & 7                    & 6                    & 6                    & 6                    & \cellcolor{blue!25}6 & 6                    & 6                    & 7                    \\\hline
			C & 8                    & 8                    & 7                    & 7                    & 7                    & 6                    & \cellcolor{blue!25}7 & 7                    & 7                    \\\hline
			A & 9                    & 9                    & 8                    & 8                    & 8                    & 7                    & 7                    & \cellcolor{blue!25}7 & 8                    \\\hline
			N & 10                   & 10                   & 9                    & 9                    & 9                    & 8                    & 8                    & 8                    & \cellcolor{blue!25}8 \\\hline

			\hline
		\end{tabular}
	\end{center}
	\caption{Edit distance matrix for REPUBLICAN $\rightarrow$ DEMOCRAT}
	\label{tab:wagnerfischermatrix}
\end{table}


The edit operations can then be inferred from $M$ by backtracking from the bottom-right
index, to the top-left, giving us the edit operations in reverse. At each position $i, j$
we choose either of the 3 surrounding indices, the same indices which were used to
determine the value originally. Choosing the left index ($i, j - 1$) equates to inserting
the character $\ArrayAccess{S_2}{j - 1}$ at position $i - 1$. Choosing the top index ($i -
1, j$) equates to deleting the character $\ArrayAccess{S_1}{i - 1}$. Choosing the top-left
index ($i - 1, j - 1$) equates to substituting $\ArrayAccess{S_1}{i - 1}$ with
$\ArrayAccess{S_2}{j - 1}$. If these characters are already equal, the operation can be
ignored. For example in table \ref{tab:wagnerfischermatrix}, the first operation is to
substitute \verb|R| with \verb|D| at position $0$. Afterwards \verb|P| and \verb|U| is
deleted at position $2$. Then the \verb|B| which is now at position $2$ is substituted by
\verb|M|. This continues with more substitutions until we finally have \verb|DEMOCRAT|.

\subsubsection{Aggregating edit operations}

In the next phase we will feed the edit operations into an algorithm which dynamically
updates our suffix array based on those operations. However, this algorithm will be more
efficient if the operations are combined to singular inserts, deletes or substitutes of
strings more than one character. The edit distance algorithm outputs only single character
operations, meaning we insert, delete or substitute a single character at a time. We
therefore want a way to combine these operations to ``larger'' operations.

We define an EditOperation with the following record:

\begin{lstlisting}
record EditOperation {
    OperationType type,
    char[] chars,
    int position
}
\end{lstlisting}

where type is either an insert, delete or subsitute.

One way to combine operations this is to find operations of the same type which are
sequenced in the matrix. For example in table \ref{tab:wagnerfischermatrix}, we have two
consecutive delete operations, where \verb|P| and \verb|U| is deleted at position $2$.
These two operations could be combined to a single delete operation of two characters.

The idea for the algorithm which computes the edit operations is to traverse the optimal
matrix path backwards and for each operation we either append to the current operation if
possible, or start a new operation. We can continue the current operation if the next
operation is of the same type, and the next operation has the same position as the current
operation. For example in table \ref{tab:wagnerfischermatrix}, we have two delete
operations in a sequence at position $1$ where \verb|P| and \verb|U| is deleted. The first
operation we encounter is the deletion of \verb|U|. At this point we create a new
\verb|EditOperation| with position $1$ and \verb|U| in the \verb|chars| array. The next
operation is also a delete operation at position $1$, so we add the \verb|P| to the list
of characters for the operation to delete. The next operation is a substitute at position
$0$, so we cannot continue the delete operation, and a new substitute operation is created
instead. Similarly, at position $2$ to $5$, we substitute \verb|BLIC| with \verb|MOCR|.
This operation is computed in a backwards fashion similarly to how we did the deletion,
except that the position of the operation is decremented for each character we add to it.

Note that this algorithm is not an optimal algorithm, as this is a trade-off between
processing many characters in few operations, versus processing many operations with few
characters. One could for example always have only two operations, deleting the whole
string, and inserting the new string. This is only two operations, but likely processes
more characters in total compared to our algorithm. This trade-off will become apparent
when discussing the dynamic suffix array updates.

\subsubsection{Optimizing memory usage and operations}

A problem with the above solution is the memory usage of the matrix. It is not feasible to
input the entire old and new fingerprint into an edit distance algorithm, as the full
fingerprint can have many million symbols, and the old and new fingerprint is likely
approximately the same size. This would require a matrix which is too large to fit in
memory. We will use a few techniques to reduce the memory usage of this algorithm without
compromising on the time complexity.

The first technique is to not input the whole fingerprint. We can drastically reduce the
size of the input by only comparing the old and new fingerprint of the document $D$ which
has been edited. $D$ stores its previous and current fingerprint, and whenever it is
edited, we can compute the edit operations of $D$, with its previous and current
fingerprint as input. However, the position of each edit operation of $D$ will not have
the correct position relative to the entire fingerprint, so $\Access{D}{start}$ is
added to the position of each edit operation to correct this.

Another optimization we can do to reduce the size of the matrix is to remove the
``trivial'' part at each end of our matrix. If we compare two strings which have many
similar characters at the beginning or end of our string, we know that these will not
equate to any edit operations in the matrix, as they will simply be diagonal moves
(substitutes) where the characters are already equal. In table
\ref{tab:minimizededitmatrix} we see the edit matrix for the input \verb|FASCINATING| and
\verb|FINISHING|. The two words share the common prefix \verb|F| and the common suffix
\verb|ING|. If we examine the edit distance values, we see that the highlighted green
matrix starts at $0$ in the top left, and ends with $6$ in the top right, which is exactly
the same values as in the full matrix. Also, we see that there are no edit operations
being added outside the green matrix. Using this knowledge, we can see that we only need
to compare the strings \verb|ASCINAT| and \verb|INISH|, which would give us the exact same
edit distance. We can also get the exact same edit operations, as long as we account for
the starting offset of the original string, so that the operations have the correct
positions. Algorithm \ref{alg:minimizededitstrings} shows how two input strings can be
minimized for usage in the edit distance algorithm. After getting the edit operations from
the algorithm, the \verb|startOffset| is added to the position of each operation to
account for the offset of the minimized matrix.

\begin{table}
	\begin{center}
		\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|c|}
			  &                      & F                     & I                     & N                     & I                     & S                     & H                     & I                    & N                    & G                    \\\hline
			  & \cellcolor{blue!25}0 & 1                     & 2                     & 3                     & 4                     & 5                     & 6                     & 7                    & 8                    & 9                    \\\hline
			F & 1                    & \cellcolor{blue!25}0  & \cellcolor{green!25}1 & \cellcolor{green!25}2 & \cellcolor{green!25}3 & \cellcolor{green!25}4 & \cellcolor{green!25}5 & 6                    & 7                    & 8                    \\\hline
			A & 2                    & \cellcolor{green!25}1 & \cellcolor{blue!25}1  & \cellcolor{green!25}2 & \cellcolor{green!25}3 & \cellcolor{green!25}4 & \cellcolor{green!25}5 & 6                    & 7                    & 8                    \\\hline
			S & 3                    & \cellcolor{green!25}2 & \cellcolor{green!25}2 & \cellcolor{blue!25}2  & \cellcolor{green!25}3 & \cellcolor{green!25}3 & \cellcolor{green!25}4 & 5                    & 6                    & 7                    \\\hline
			C & 4                    & \cellcolor{green!25}3 & \cellcolor{green!25}3 & \cellcolor{blue!25}3  & \cellcolor{green!25}3 & \cellcolor{green!25}4 & \cellcolor{green!25}4 & 5                    & 6                    & 7                    \\\hline
			I & 5                    & \cellcolor{green!25}4 & \cellcolor{green!25}3 & \cellcolor{green!25}4 & \cellcolor{blue!25}3  & \cellcolor{green!25}4 & \cellcolor{green!25}5 & 4                    & 5                    & 6                    \\\hline
			N & 6                    & \cellcolor{green!25}5 & \cellcolor{green!25}4 & \cellcolor{green!25}3 & \cellcolor{green!25}4 & \cellcolor{blue!25}4  & \cellcolor{green!25}5 & 5                    & 4                    & 5                    \\\hline
			A & 7                    & \cellcolor{green!25}6 & \cellcolor{green!25}5 & \cellcolor{green!25}4 & \cellcolor{green!25}4 & \cellcolor{green!25}5 & \cellcolor{blue!25}5  & 6                    & 5                    & 5                    \\\hline
			T & 8                    & \cellcolor{green!25}7 & \cellcolor{green!25}6 & \cellcolor{green!25}5 & \cellcolor{green!25}5 & \cellcolor{green!25}5 & \cellcolor{blue!25}6  & 6                    & 6                    & 6                    \\\hline
			I & 9                    & 8                     & 7                     & 6                     & 5                     & 6                     & 6                     & \cellcolor{blue!25}6 & 7                    & 7                    \\\hline
			N & 10                   & 9                     & 8                     & 7                     & 6                     & 6                     & 7                     & 7                    & \cellcolor{blue!25}6 & 7                    \\\hline
			G & 11                   & 10                    & 9                     & 8                     & 7                     & 7                     & 7                     & 8                    & 7                    & \cellcolor{blue!25}6 \\\hline \end{tabular} \end{center} \caption{Edit distance matrix for FASCINATING $\rightarrow$ FINISHING. Blue
		is optimal path, green is minimized matrix}
	\label{tab:minimizededitmatrix}
\end{table}

\begin{algorithm}[htp]
  \SetAlgoLined\DontPrintSemicolon
    \algo{\EditDistanceMinimizeStrings{$S_1$, $S_2$}}{

        \For{$i \From 0 \To \Min{$\Len{$\Var{S}_1$}, \Len{$\Var{S}_1$}$}$}{
            \If{$\ArrayAccess{\Var{S_1}}{\Var{i}} \neq \ArrayAccess{\Var{S_2}}{\Var{i}}$}{
                \Break
            }
        }
        $\Var{startOffset} \gets i$ \;\;


        $\Var{s1End} \gets \Len{$\Var{S}_1$} - 1$ \;
        $\Var{s2End} \gets \Len{$\Var{S}_2$} - 1$ \;

        \While{$\Var{s1End} \geq \Var{startOffset} \And \Var{s2End} \geq
        \Var{startOffset} \And \ArrayAccess{\Var{S_1}}{\Var{s1End}} =
        \ArrayAccess{\Var{S_2}}{\Var{s2End}}$}{
            $\Var{s1End} \gets \Var{s1End} - 1$ \;
            $\Var{s2End} \gets \Var{s2End} - 1$ \;
        } \;

        $\Var{miniS1} \gets \ArrayAccess{\Var{S}_1}{\Var{startOffset}...\Var{s1End}}$ \;
        $\Var{miniS2} \gets \ArrayAccess{\Var{S}_2}{\Var{startOffset}...\Var{s2End}}$ \;\;

        \Return{$(\Var{miniS1}, \Var{miniS2}, \Var{startOffset})$}
    }

  \vspace{0.5cm}
  \caption{Minimize strings for edit distance algorithm}
  \label{alg:minimizededitstrings}
\end{algorithm}

The two optimizations drastically reduce the memory usage of the edit distance algorithm,
but in cases where a very large file is edited, and the beginning and end of the old and
new fingerprint do not match, we can still encounter instances of the matrix being too
large to fit in memory. The problem is that the matrix size has a polynomial growth in
terms of the fingerprint size. This is because the old fingerprint is of size $n$ and the
new fingerprint is of size $m$, where $n \approx m$, which requires an $n * m$ size matrix
to calculate the edit operations. For example if a Java file contains $3000$ lines, the
number of tokens can exceed $10000$, which would require approximately a $10000 * 10000$
size matrix, which is approaching a memory usage which too large.

A solution to this problem is to reduce the required memory from the polinomial $O(n*m)$
memory usage, to a linear $O(n)$ memory usage. A stepping stone towards such a solution is
an observation attributed to Ukkonen, which reduces the required memory to linear growth
in the size of either of the strings~\cite{UkkonenEditDistance}. The observation shows
that in order to compute the next row/column of the edit distance matrix, we only need the
previous row/column. For example in table \ref{tab:minimalmemoryusageeditdistance}, the
fifth row has been computed using only the fourth row. This is done by first computing the
left-most index of the fifth row, which is always one more than the previous row.
Afterwards, we can compute the other elements of the row from left to right, with the same
recurrence, shown in equation \ref{eq:editdistancerecurrence}. This is possible because we
always know the above, left, and top-left elements of the current index. This can be
implemented as two arrays, which holds the previous and current row. 

\begin{table}
	\begin{center}
		\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|}
			  &   & D & E & M & O & C & R & A & T \\\hline
			  &   &   &   &   &   &   &   &   &   \\\hline
			R &   &   &   &   &   &   &   &   &   \\\hline
			E &   &   &   &   &   &   &   &   &   \\\hline
			P & 3 & 3 & 2 & 2 & 3 & 4 & 5 & 6 & 7 \\\hline
			U & 4 & 4 & 3 & 3 & 3 & 4 & 5 & 6 & 7 \\\hline
			B &   &   &   &   &   &   &   &   &   \\\hline
			L &   &   &   &   &   &   &   &   &   \\\hline
			I &   &   &   &   &   &   &   &   &   \\\hline
			C &   &   &   &   &   &   &   &   &   \\\hline
			A &   &   &   &   &   &   &   &   &   \\\hline
			N &   &   &   &   &   &   &   &   &   \\\hline
		\end{tabular}
	\end{center}
	\caption{Edit distance matrix with minimal memory usage}
	\label{tab:minimalmemoryusageeditdistance}
\end{table}

This change allows us to compute the edit distance in linear space, but now the problem is
how to find the actual edit operation. This is not possible, because we don't have the
entire matrix available to traverse anymore. However, this can be solved using
Hirschberg's algorithm~\cite{HirschbergsAlgorithm}. Hirschberg's algorithm is an algorithm
which can compute the edit operations of two strings in the same time complexity as the
Wagner-Fischer algorithm, but uses only linear space.

The first observation we need to make for this algorithm is that there is at minimum one
edit operation on each row/column of the edit distance matrix. This is intuitive, because
in order to ``travel'' from the top-left to the bottom-right of the matrix, we need to
travel from the top to the bottom, visiting all the rows, and from the left to the right,
visiting all the columns. Hirschberg's algorithm uses this observation to compute one
position of the optimal path at a time, which it finds in the middle row between two
already known positions of the path. Table \ref{tab:hirschbergs} shows an example of how
the positions are found.

\begin{table}
	\begin{center}
        \begin{tabular}[c]{cc}
		\scalebox{0.8}{
			\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|c|}
				  &                        & F                     & I                     & N                     & I                    & S                     & H                     & I                     & N                      & G                      \\\hline
				  & \cellcolor{blue!25}    & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				F & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				A & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				S & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				C & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				I & \cellcolor{green!25}10 & \cellcolor{green!25}8 & \cellcolor{green!25}6 & \cellcolor{green!25}7 & \cellcolor{blue!75}6 & \cellcolor{green!25}7 & \cellcolor{green!25}8 & \cellcolor{green!25}8 & \cellcolor{green!25}10 & \cellcolor{green!25}12 \\\hline
				N & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				A & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				T & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				I & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				N & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{green!25}   \\\hline
				G & \cellcolor{green!25}   & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}   & \cellcolor{blue!25}    \\\hline
			\end{tabular}
        } &

		\scalebox{0.8}{
			\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|c|}
				  &                       & F                     & I                    & N                     & I                     & S                     & H                    & I                     & N                     & G                     \\\hline
				  & \cellcolor{blue!25}   & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  &                       &                      &                       &                       &                       \\\hline
				F & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  &                       &                      &                       &                       &                       \\\hline
				A & \cellcolor{green!25}5 & \cellcolor{green!25}3 & \cellcolor{blue!75}3 & \cellcolor{green!25}4 & \cellcolor{green!25}6 &                       &                      &                       &                       &                       \\\hline
				S & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  &                       &                      &                       &                       &                       \\\hline
				C & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  &                       &                      &                       &                       &                       \\\hline
				I & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{blue!25}   & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  \\\hline
				N &                       &                       &                      &                       & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  \\\hline
				A &                       &                       &                      &                       & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  \\\hline
				T &                       &                       &                      &                       & \cellcolor{green!25}5 & \cellcolor{green!25}4 & \cellcolor{blue!75}3 & \cellcolor{green!25}4 & \cellcolor{green!25}6 & \cellcolor{green!25}8 \\\hline
				I &                       &                       &                      &                       & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  \\\hline
				N &                       &                       &                      &                       & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25}  \\\hline
				G &                       &                       &                      &                       & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{blue!25}   \\\hline
			\end{tabular}
        } \\
        \addlinespace[1cm]
		\scalebox{0.8}{
			\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|c|}
				                     &                       & F                     & I                     & N                    & I                     & S                     & H                    & I                    & N                    & G                    \\\hline
				                     & \cellcolor{blue!25}0  & \cellcolor{green!25}1 & \cellcolor{green!25}2 &                      &                       &                       &                      &                      &                      &                      \\\hline
				F                    & \cellcolor{green!25}1 & \cellcolor{blue!75}0  & \cellcolor{green!25}1 &                      &                       &                       &                      &                      &                      &                      \\\hline
				A                    & \cellcolor{green!25}2 & \cellcolor{green!25}1 & \cellcolor{blue!25}1  & \cellcolor{green!25} & \cellcolor{green!25}  &                       &                      &                      &                      &                      \\\hline
				S                    &                       &                       & \cellcolor{green!25}2 & \cellcolor{blue!75}2 & \cellcolor{green!25}4 &                       &                       &                      &                       &                                                                                                                   \\\hline
				C                    &                       &                       & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{green!25}  &                       &                      &                      &                      &                      \\\hline
				I                    &                       &                       & \cellcolor{green!25}  & \cellcolor{green!25} & \cellcolor{blue!25}   & \cellcolor{green!25}  & \cellcolor{green!25} &                      &                      &                      \\\hline
				N                    &                       &                       &                       & & \cellcolor{blue!75}3  & \cellcolor{green!25}3 & \cellcolor{green!25}4 &                      &                       &                                                                                                                   \\\hline
				A                    &                       &                       &                       &                      & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{green!25} &                      &                      &                      \\\hline
				T                    &                       &                       &                       &                      & \cellcolor{green!25}  & \cellcolor{green!25}  & \cellcolor{blue!25}  & \cellcolor{green!25} & \cellcolor{green!25} & \cellcolor{green!25} \\\hline
				I                    &                       &                       &                       & &                       &                       & \cellcolor{green!25}2 & \cellcolor{blue!75}0 & \cellcolor{green!25}2 & \cellcolor{green!25}4                                                                                             \\\hline
				N                    &                       &                       &                       &                      &                       &                       & \cellcolor{green!25} & \cellcolor{green!25} & \cellcolor{green!25} & \cellcolor{green!25} \\\hline
				G                    &                       &                       &                       &                      &                       &                       & \cellcolor{green!25} & \cellcolor{green!25} & \cellcolor{green!25} & \cellcolor{blue!25}  \\\hline
			\end{tabular}
        }&
		\scalebox{0.8}{
			\begin{tabular}[c]{c|c|c|c|c|c|c|c|c|c|c|}
				  &                     & F                   & I                   & N                     & I                     & S                     & H                     & I                     & N                     & G                     \\\hline
				  & \cellcolor{blue!25} &                     &                     &                       &                       &                       &                       &                       &                       &                       \\\hline
				F &                     & \cellcolor{blue!25} &                     &                       &                       &                       &                       &                       &                       &                       \\\hline
				A &                     &                     & \cellcolor{blue!25} &                       &                       &                       &                       &                       &                       &                       \\\hline
				S &                     &                     &                     & \cellcolor{blue!25}0  & \cellcolor{green!25}1 &                       &                       &                       &                       &                       \\\hline
				C &                     &                     &                     & \cellcolor{blue!75}1  & \cellcolor{green!25}1 &                       &                       &                       &                       &                       \\\hline
				I &                     &                     &                     & \cellcolor{green!25}2 & \cellcolor{blue!25}1  &                       &                       &                       &                       &                       \\\hline
				N &                     &                     &                     &                       & \cellcolor{blue!25}0  & \cellcolor{green!25}1 & \cellcolor{green!25}2 &                       &                       &                       \\\hline
				A &                     &                     &                     &                       & \cellcolor{green!25}1 & \cellcolor{blue!75}1  & \cellcolor{green!25}2 &                       &                       &                       \\\hline
				T &                     &                     &                     &                       & \cellcolor{green!25}2 & \cellcolor{green!25}2 & \cellcolor{blue!25}2  &                       &                       &                       \\\hline
				I &                     &                     &                     &                       &                       &                       &                       & \cellcolor{blue!25}0  & \cellcolor{green!25}1 & \cellcolor{green!25}2 \\\hline
				N &                     &                     &                     &                       &                       &                       &                       & \cellcolor{green!25}1 & \cellcolor{blue!75}0  & \cellcolor{green!25}1 \\\hline
				G &                     &                     &                     &                       &                       &                       &                       & \cellcolor{green!25}2 & \cellcolor{green!25}1 & \cellcolor{blue!25}0  \\\hline
			\end{tabular}
		}
        \end{tabular}
	\end{center}
	\caption{Hirschberg's algorithm. Blue cells are part of the optimal path, dark-blue
    cells are new positions.}
	\label{tab:hirschbergs}
\end{table}

Initially, we know that the top-left index, and the bottom-right index of the matrix are
guaranteed to be part of the optimal path, since those positions are the starting and
ending point of the path. The next position to find is in the middle row of the matrix.
Determining which position in the middle row should be selected is done by performing the
edit distance recurrence twice, once from the beginning to the middle row in the same
fashion as the original algorithm, and once in reverse, from the bottom-right to the
middle row. Both of the recurrences can run in linear space, because we only need to store
two rows at a time. Summing the two results for the middle row gives us an array which can
intuitively be understood as how long the minimal path which goes through the
corresponding position in the row is. Since we know that there is at least one of the
positions in this row which has to be part of the optimal path, the minimum value in this
array corresponds to one position which has to be part of the optimal path. Once we know
the middle position which is part of the optimal path, we can recursively call the
function twice, once with the top-left and middle as input, and once with the middle and
bottom-right as input. The base-case of the recursion is when the size of the matrix is
linear in the size of either of the strings, in which case we call the Wagner-Fischer edit
distance recurrence with a linear space complexity. Note that there can be multiple
minimum values in the row where a position is selected, which corresponds to the fact that
there can be multiple optimal paths through the matrix.

Each position which is a part of the optimal path is stored as they are found, and can
then be traversed backwards to determine the edit operations similarly to traversing the
matrix. For example if we iterate over the list of positions backwards, we will know that
if the first position is at $x, y$ and the second position is at $x - 1, y$, that
corresponds to a delete operation, just as in the matrix-based algorithm.

Using Hirschberg's algorithm, we are now able to compute the edit operations for very
large files without memory usage issues.


\section{Dynamic suffix arrays}

Now that we know how the fingerprint has changed after an edit, the next phase is to input
the edit operations into an algorithm which dynamically updates the suffix array. The goal
of this algorithm is to take the previous suffix array, and an edit operation, and compute
the new suffix array faster than it would take to build the suffix array from scratch.

The algorithm used is the algorithm by Salson et al. ~\cite{DynamicExtendedSuffixArrays}.
This algorithm is based on the 4-stage algorithm for updating a Burrows-Wheeler transform
(BWT), also by Salson et al.~\cite{DynamicBWT}. Recall that the Burrows-Wheeler transform
is a transform on an input string which is often used for compression and text-search
purposes. The BWT is also reversible by using the LF function to compute the original
string in reverse. Also, recall that the suffix array and the BWT of a string is tightly
related to the point where one can compute the BWT from the suffix array. The algorithm
which dynamically updates the BWT can therefore be used to dynamically update the suffix
array as well.

\subsubsection{Updating BWT}

First we will observe which parts of a BWT changes when we insert a single character. Note
that we will only consider what changes for the BWT string, meaning the final character in
each shift, not the whole cyclic-shift. For the String \verb|BANANA$|, we insert a
\verb|B| at position $2$, giving us the string \verb|BABNANA$|. In table
\ref{table:bwtupdate} we can see that some parts of the BWT is preserved, such as
\verb|$AA| and \verb|AN|, but some changes have naturally occurred. We know that we will
have exactly one more cyclic-shift for the string, which starts with the inserted
character \verb|B| and ends with the character at position $2 - 1 = 1$ which is \verb|A|.
We also know that exactly one cyclic-shift will change its last character, which is the
cyclic-shift previously starting at position $2$, but is now at position $3$ after the
insert. This cyclic-shift will now end with the new inserted character, \verb|B|. These
are the only changes to the cyclic-shifts which happen (which matter for the BWT), but it
is also possible that the cyclic-shifts change their ordering because of the new
character. For example \verb|ANANA$B| $<$ \verb|ANA$BAN|, but \verb|ABNANA$B| $>$
\verb|ANA$BABN|. A useful observation is that only cyclic-shifts of order $j \leq 2$ will
have its lexicographical ordering changed. This is because only these cyclic-shifts are
the ones where the inserted \verb|B| comes before the \verb|$|. Since the \verb|$| is the
smallest lexicographical character, and no cyclic-shift will have \verb|$| in the same
location, we know that the lexicographical comparison of two cyclic-shifts will never go
past the \verb|$|. Therefore, only the cyclic-shifts where the inserted character comes
before the \verb|$|, has the possibility of being moved.

\begin{table}[!htb]
	\begin{center}
		\subfloat[S = BANANA\$]{
			\begin{tabular}{c | l}
				Index & Cyclic-shift \\
				\hline
				6     & \$BANAN\textbf{A}   \\
				5     & A\$BANA\textbf{N}   \\
				3     & ANA\$BA\textbf{N}   \\
				1     & ANANA\$\textbf{B}   \\
				0     & BANANA\textbf{\$}   \\
				4     & NA\$BAN\textbf{A}   \\
				2     & NANA\$B\textbf{A}   \\
			\end{tabular}
		}
        \hspace{1cm}
		\subfloat[S = BABNANA\$]{
			\begin{tabular}{c | l}
				Index & Cyclic-shift \\
				\hline
				7     & \$BABNAN\textbf{A}   \\
				6     & A\$BABNA\textbf{N}   \\
				1     & ABNANA\$\textbf{B}   \\
				4     & ANA\$BAB\textbf{N}   \\
				0     & BABNANA\textbf{\$}   \\
				2     & BNANA\$B\textbf{A}   \\
				5     & NA\$BABN\textbf{A}   \\
				3     & NANA\$BA\textbf{B}   \\
			\end{tabular}
		}
		\caption{BWT for string before and after insert}
		\label{table:bwtupdate}
	\end{center}
\end{table}

In the example in \ref{table:bwtupdate}, we see that the new cyclic-shift is
\verb|BNANA$BA|, and the changed cyclic-shift is \verb|NANA$BAB|. We can find where these
cyclic-shifts are located by first looking up the insert position in the ISA. $\ISA{2} =
6$. This is the cyclic-shift (\verb|NANA$BA|) where the final character is updated to the
inserted character \verb|B|. To find the position where the new cyclic-shift should be
inserted, we can use the LF-function to move from the current cyclic-shift
to the previous. Computing $LF(6)$ after the substitute gives us $5$, which is where the
new cyclic-shift should be inserted.

\begin{table}[!htb]
	\begin{center}
		\subfloat[Original BWT]{
			\begin{tabular}{c | l | l}
                Index & L & F \\
				\hline
                6     & \$ & \textbf{A}   \\
                5     & A &\textbf{N}   \\
                3     & A & \textbf{N}   \\
                1     & A & \textbf{B}   \\
                0     & B & \textbf{\$}   \\
                4     & N & \textbf{A}   \\
                2     & N & \textbf{A}   \\
			\end{tabular}
		}
        \hspace{1cm}
		\subfloat[After change and insert]{
			\begin{tabular}{c | l | l}
                Index & L & F \\
				\hline
                7     & \$ & \textbf{A}   \\
                6     & A & \textbf{N}   \\
                4     & A & \textbf{N}   \\
                2     & A & \textbf{B}   \\
                0     & B & \textbf{\$}   \\
                1     & B & \textbf{A}   \\
                5     & B & \textbf{A}   \\
                3     & N & \textbf{B}   \\
			\end{tabular}
		}
		\caption{BWT for string before and after insert}
		\label{table:bwtupdate}
	\end{center}
\end{table}


The final stage of the algorithm now that all the elements are present, is to rearrange
the cyclic-shifts which have changed their lexicographical ordering. We know that 


\section{Storing old clones}

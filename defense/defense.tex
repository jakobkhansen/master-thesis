\documentclass[aspectratio=1610]{beamer}


\usepackage{listings}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{subfig}
\def\addsquare#1{\tikz\node[draw]{#1};}
\def\addcircle#1{\tikz\node[draw,circle]{#1};}



\usepackage{xcolor}
\definecolor{pgreen}{rgb}{0,0.5,0}

\usetheme{Antibes}

\lstset{
    language=Java,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{pgreen},
    stringstyle=\color{pgreen},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3,
    escapeinside={(*}{*)},
    aboveskip=-1em,
    belowskip=-1em,
}

%Information to be included in the title page:
\title{Incremental clone detection for IDEs using dynamic suffix arrays}
\author{Jakob Konrad Hansen}
\institute{University of Oslo}
\date{2023}



\begin{document}

\frame{\titlepage}

\begin{frame}
    \frametitle{Outline}
    \tableofcontents
\end{frame}

\section{Motivation and contribution}

\begin{frame}
\frametitle{Motivation}
\begin{itemize}
    \item Duplicated code is generally considered harmful to software quality
    \item Code clone detection, analysis and management is therefore important
    \item Incremental clone detection algorithms have not been thoroughly researched
    \item Incremental algorithms are useful in use-cases such as in IDEs
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Our contribution}
\begin{itemize}
    \item CCDetect-LSP: An incremental clone detection tool for IDEs
    \item Uses a novel application of dynamic extended suffix arrays for clone detection
    \item Language- and IDE agnostic via Tree-sitter and LSP
\end{itemize}
\end{frame}

\section{Background}

\subsection{Code clone theory}

\begin{frame}
    \frametitle{Code clones}

    \begin{definition}[Code snippet]
        A code snippet is a piece of contiguous source code in a larger software system.
    \end{definition}

    \begin{definition}[Code clone]
        A code clone is a code snippet which is equal or similar to another code snippet. The two
        code snippets are both code clones, and together they form a clone pair.
        Similarity is determined by some metric such as number of equal lines of code.
    \end{definition}
\end{frame}

\begin{frame}
	\frametitle{Clone types}
	\begin{itemize}
		\item Code clones are classified into four types
		      \begin{itemize}
			      \item Type-1: Syntactically identical
			      \item Type-2: Structurally identical
			      \item Type-3: Structurally similar
			      \item Type-4: Functionally similar (generally)
		      \end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Clone type examples: type-1 and type-2}
    \begin{figure}[t]
		\begin{center}
			\begin{tabular}{c | c}
				\begin{lstlisting}
for (int i = 0; i < 10;   i++) {
    print(i);
}
\end{lstlisting} &
				\begin{lstlisting}
for (int i = 0; i < 10; i++) {
    // A comment

    print(i);
}
            \end{lstlisting}
			\end{tabular}
		\end{center}
        \caption{Type-1 clone pair}
    \end{figure}
    \begin{figure}[t]
        	\begin{center}
        \begin{tabular}{p{6cm} | p{6cm}}
\begin{lstlisting}
for (int i = 0; i < 10; i++) {
    print(i);
}
\end{lstlisting} & \begin{lstlisting}
for (int (*\textbf j*) = (*\textbf 5*); (*\textbf j*) < (*\textbf{20}*); (*\textbf j++*)) {
    print((*\textbf j*));
}
\end{lstlisting}
		\end{tabular}
	\end{center}

        \caption{Type-2 clone pair}
    \end{figure}

\end{frame}


\begin{frame}[fragile]
	\frametitle{Clone type examples: type-3 and type-4}
    \vspace{0.5cm}
	\begin{figure}[t]
		\begin{center}
			\begin{tabular}{p{6cm} | p{6cm}}
				\begin{lstlisting}
for (int i = 0; i < 10; i++) {
    print(i);
}\end{lstlisting} &
				\begin{lstlisting}
for (int i = 0; i < 10; i++) {
    print(i);
    print(i*2);
}\end{lstlisting}
			\end{tabular}
		\end{center}
		\caption{Type-3 clone pair}
		\label{fig:type3clone}
	\end{figure}
    \vspace{-0.5cm}

	\begin{figure}[t]
		\begin{center}
			\begin{tabular}{r | p{6.5cm}}
				\hspace{3.2cm}\begin{lstlisting}
print((n*(n-1))/2)
\end{lstlisting} &
				\begin{lstlisting}
int sum = 0;
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        sum++;
    }
}
print(sum);
            \end{lstlisting}
			\end{tabular}
		\end{center}
		\caption{Type-4 clone pair}
		\label{fig:type4clone}
	\end{figure}
\end{frame}

\begin{frame}{Clone detection}
    \begin{figure}
        \begin{center}
            \includegraphics[width=0.95\textwidth]{figures/detectionphases.drawio.pdf}
        \end{center}
    \end{figure}
\end{frame}

\begin{frame}{Clone matching techniques}
    \begin{itemize}
        \item Text-based detection
            \begin{itemize}
                \item Match based on raw source code
            \end{itemize}
        \item Token-based detection
            \begin{itemize}
                \item Match based on tokens
            \end{itemize}
        \item Syntactic detection
            \begin{itemize}
                \item Match based on AST
            \end{itemize}
        \item Hybrid detection
            \begin{itemize}
                \item Combine multiple approaches
            \end{itemize}
    \end{itemize}
\end{frame}


\subsection{Preliminary algorithms and data structures}
\begin{frame}{Parsing and incremental parsing}
    \begin{figure}
        \begin{center}
            \includegraphics[width=0.95\textwidth]{figures/incrementalparsing.drawio.pdf}
        \end{center}
    \end{figure}
\end{frame}

\begin{frame}{Suffixes}
	\begin{definition}
		A suffix of a string $S$ is any nonempty substring which reaches the end of $S$. The suffix
		at position $i$ of $S$ is denoted $\text{Suffix}(S, i)$.
	\end{definition}
\end{frame}

\begin{frame}{Suffix tree}
	\begin{figure}
		\begin{center}
			\begin{tikzpicture}[every tree node,
					level distance=1.25cm,sibling distance=1cm,
					edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}]
				\Tree
				[.\addcircle{}
				\edge node[midway, above, sloped] {\$};
				[.\addsquare{6} ]
				\edge node[midway, below, sloped] {BANANA\$};
				[.\addsquare{0} ]
				\edge node[midway, above, sloped] {A};
				[.\addcircle{}
				\edge node[midway, above, sloped] {\$};
				[.\addsquare{5} ]
				\edge node[midway, above, sloped] {NA};
				[.\addcircle{}
				\edge node[midway, above, sloped] {\$};
				[.\addsquare{3} ]
				\edge node[midway, above, sloped] {NA\$};
				[.\addsquare{1} ]
				]
				]
				\edge node[midway, above, sloped] {NA};
				[.\addcircle{}
				\edge node[midway, above, sloped] {\$};
				[.\addsquare{4} ]
				\edge node[midway, above, sloped] {NA\$};
				[.\addsquare{2} ]
				]
				]
			\end{tikzpicture}
			\caption{Suffix tree for $S=\text{BANANA\$}$}
			\label{fig:suffixtree}
		\end{center}
	\end{figure}
\end{frame}

\begin{frame}{Suffix array}
    \begin{definition}[Suffix array] 

        Let $S$ be a string of length N. The suffix array SA of $S$ is an array of length
        N where $\text{SA}[i] = n$ if $\text{Suffix}(S, n)$ is the ith lexicographically
        smallest suffix in $S$.
        
    \end{definition}

    \begin{definition}[LCP array] 

        Let S be a string of length N and SA be the suffix array of S. The LCP array of S
        is an array of length N where $\text{LCP[i] = n}$ if $\text{Suffix}(S, SA[i])$ and
        $\text{Suffix}(S, SA[i - 1])$ has a maximal common prefix of length $\text{n}$.
        $\text{LCP[0]}$ is undefined or {0}. 

    \end{definition}
\end{frame}

\begin{frame}{Suffix array}
	\begin{table}
		\begin{center}
			\subfloat[Suffixes]{
				\begin{tabular}{c | l }
					Index & Suffix   \\
					\hline
					0     & BANANA\$ \\
					1     & ANANA\$  \\
					2     & NANA\$   \\
					3     & ANA\$    \\
					4     & NA\$     \\
					5     & A\$      \\
					6     & \$       \\
				\end{tabular}}
			\hspace{1cm}
			\subfloat[Sorted suffixes]{\begin{tabular}{c | l}
					Index & Suffix   \\
					\hline
					6     & \$       \\
					5     & A\$      \\
					3     & ANA\$    \\
					1     & ANANA\$  \\
					0     & BANANA\$ \\
					4     & NA\$     \\
					2     & NANA\$   \\
				\end{tabular}}
			\hspace{1cm}
			\subfloat[SA, ISA and LCP]{\begin{tabular}{c | c | c | c}
					Index & SA & ISA & LCP \\
					\hline
					0     & 6  & 4   & 0   \\
					1     & 5  & 3   & 0   \\
					2     & 3  & 6   & 1   \\
					3     & 1  & 2   & 3   \\
					4     & 0  & 5   & 0   \\
					5     & 4  & 1   & 0   \\
					6     & 2  & 0   & 2   \\
				\end{tabular}}
		\end{center}
	\end{table}
\end{frame}

\begin{frame}
\end{frame}

\section{Implementation}

\subsection{LSP architecture and functionality + demo}

\begin{frame}{Implementation: LSP architecture and functionality}
	\begin{itemize}
		\item The Language Server Protocol (LSP) facilitates IDE agnostic tooling
		\item CCDetect-LSP is implemented as an LSP server
	\end{itemize}
\end{frame}

\subsection{Initial clone detection}

\begin{frame}{Implementation: Initial clone detection}
\end{frame}

\subsection{Incremental clone detection}
\begin{frame}{Implementation: Incremental clone detection}
\end{frame}

\section{Evaluation}
\begin{frame}{Results}
\end{frame}

\section{Discussion}
\begin{frame}{Discussion}
\end{frame}

\section{Conclusion}
\begin{frame}{Conclusion}
\end{frame}

\end{document}
